"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[304],{7580:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"why-use-quickzone","title":"Why use QuickZone?","description":"Before integrating a new library, you might need some convincing of why you shouldn\'t just use Roblox\'s built-in .Touched event or workspace:GetPartsInPart. That\'s totally fair! The following text explains the engineering challenges of spatial queries in Roblox and how QuickZone solves them through advanced algorithms and low-level optimizations.","source":"@site/docs/why-use-quickzone.md","sourceDirName":".","slug":"/why-use-quickzone","permalink":"/QuickZone/docs/why-use-quickzone","draft":false,"unlisted":false,"editUrl":"https://github.com/LDgerrits/QuickZone/edit/main/docs/why-use-quickzone.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"defaultSidebar","previous":{"title":"Usage","permalink":"/QuickZone/docs/usage"}}');var t=i(4848),o=i(8453);const r={sidebar_position:3},a="Why use QuickZone?",l={},c=[{value:"The Problem with Physics",id:"the-problem-with-physics",level:2},{value:"The <code>.Touched</code> Event",id:"the-touched-event",level:3},{value:"Spatial Queries (<code>GetPartsInPart</code>)",id:"spatial-queries-getpartsinpart",level:3},{value:"The QuickZone Solution",id:"the-quickzone-solution",level:2},{value:"1. Bounding Volume Hierarchy (BVH)",id:"1-bounding-volume-hierarchy-bvh",level:3},{value:"2. Data-Oriented Design (DOD)",id:"2-data-oriented-design-dod",level:3},{value:"3. The Frame Budget (Fixing Starvation)",id:"3-the-frame-budget-fixing-starvation",level:3},{value:"Implementation Detail",id:"implementation-detail",level:2}];function h(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"why-use-quickzone",children:"Why use QuickZone?"})}),"\n",(0,t.jsxs)(n.p,{children:["Before integrating a new library, you might need some convincing of why you shouldn't just use Roblox's built-in ",(0,t.jsx)(n.code,{children:".Touched"})," event or ",(0,t.jsx)(n.code,{children:"workspace:GetPartsInPart"}),". That's totally fair! The following text explains the engineering challenges of spatial queries in Roblox and how QuickZone solves them through advanced algorithms and low-level optimizations."]}),"\n",(0,t.jsx)(n.h2,{id:"the-problem-with-physics",children:"The Problem with Physics"}),"\n",(0,t.jsx)(n.p,{children:"Traditionally, developers rely on the Roblox Physics engine to detect when a player enters a zone."}),"\n",(0,t.jsxs)(n.h3,{id:"the-touched-event",children:["The ",(0,t.jsx)(n.code,{children:".Touched"})," Event"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:".Touched"})," event is the oldest method. It relies on physical collisions."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tunneling:"})," Fast-moving objects (like cars or falling players) can skip over a zone entirely between physics steps, never firing the event."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance:"})," It requires parts to be physically present in the workspace. If you have 1,000 zones, you have 1,000 extra parts adding to the physics simulation overhead, even if they are ",(0,t.jsx)(n.code,{children:"CanCollide = false"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reliability:"})," It doesn't fire if the part is not moving relative to the zone."]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"spatial-queries-getpartsinpart",children:["Spatial Queries (",(0,t.jsx)(n.code,{children:"GetPartsInPart"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["The modern alternative is ",(0,t.jsx)(n.code,{children:"workspace:GetPartsInPart"}),". While accurate, it is effectively a 'Brute Force' physics check."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cost:"})," It has to calculate precise collision geometry (OOB/Convex Decomposition). Doing this for 50 zones every frame is incredibly expensive."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Garbage:"})," It allocates a new table and new instances every time you call it, causing frequent Garbage Collection (GC) spikes."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"the-quickzone-solution",children:"The QuickZone Solution"}),"\n",(0,t.jsxs)(n.p,{children:["QuickZone was built with one goal: ",(0,t.jsx)(n.strong,{children:"Maximum Performance with Minimal Footprint."})," It bypasses the physics engine entirely in favor of pure geometric math and data-oriented design."]}),"\n",(0,t.jsx)(n.h3,{id:"1-bounding-volume-hierarchy-bvh",children:"1. Bounding Volume Hierarchy (BVH)"}),"\n",(0,t.jsx)(n.p,{children:"If you have 100 players and 100 zones, a naive script would perform 10,000 checks per frame ($O(N \\times M)$). As your game grows, this logic causes lag."}),"\n",(0,t.jsxs)(n.p,{children:["QuickZone implements a ",(0,t.jsx)(n.strong,{children:"Linear Bounding Volume Hierarchy"}),".\nA BVH organizes your zones into a tree structure. When checking if a player is in a zone, we first check the 'root' of the tree. If the player isn't in the root, we instantly know they aren't in ",(0,t.jsx)(n.em,{children:"any"})," of the 1,000 zones inside it."]}),"\n",(0,t.jsx)(n.p,{children:"This turns an $O(N)$ search into an $O(\\log N)$ search. In practice, this means QuickZone can query thousands of zones in microseconds."}),"\n",(0,t.jsx)(n.h3,{id:"2-data-oriented-design-dod",children:"2. Data-Oriented Design (DOD)"}),"\n",(0,t.jsx)(n.p,{children:"Most Lua libraries heavily use Object-Oriented Programming (OOP), creating a new table/class for every single bullet or entity."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"The Problem:"})," Lua tables are expensive memory allocations. Creating wrapper objects (",(0,t.jsx)(n.code,{children:"Entity.new(part)"}),") for 1,000 projectiles creates massive GC pressure (lag spikes)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"The Solution:"})," QuickZone uses a Data-Oriented approach. We don't wrap your parts in objects. We track them in flat arrays and use the Instances themselves as keys."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This results in ",(0,t.jsx)(n.strong,{children:"Zero-Allocation Hot Loops"}),". Once the system is running, the scheduler generates almost no garbage, keeping your memory usage flat and your GC pauses non-existent."]}),"\n",(0,t.jsx)(n.h3,{id:"3-the-frame-budget-fixing-starvation",children:"3. The Frame Budget (Fixing Starvation)"}),"\n",(0,t.jsx)(n.p,{children:"A common issue with loop-based checks is 'Starvation.'\nIf you have 5,000 zombies to check, the loop might take 8ms. If your game is already running heavy logic, that 8ms push might drop you below 60 FPS."}),"\n",(0,t.jsxs)(n.p,{children:["QuickZone includes a ",(0,t.jsx)(n.strong,{children:"Frame Budget Scheduler"}),"."]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"You set a budget (e.g., 2ms)."}),"\n",(0,t.jsx)(n.li,{children:"The scheduler processes as many entities as it can within that 2ms."}),"\n",(0,t.jsxs)(n.li,{children:["If it runs out of time, it ",(0,t.jsx)(n.strong,{children:"pauses"})," and resumes exactly where it left off on the next frame."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This guarantees that ",(0,t.jsx)(n.strong,{children:"QuickZone will never be the cause of your frame drops"}),", no matter how many entities you throw at it. It favors 'Eventual Consistency' over 'Lag.'"]}),"\n",(0,t.jsx)(n.h2,{id:"implementation-detail",children:"Implementation Detail"}),"\n",(0,t.jsx)(n.p,{children:"Let's look at a comparison."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"The Naive Way (Laggy):"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-lua",children:"RunService.Heartbeat:Connect(function()\n    for _, zone in zones do\n        -- Allocates a new table every single frame for every single zone\n        local parts = workspace:GetPartsInPart(zone.Part) \n        for _, part in parts do\n            -- heavy logic...\n        end\n    end\nend)\n"})})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var s=i(6540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);